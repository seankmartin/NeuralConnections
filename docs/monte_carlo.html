<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1, minimum-scale=1" />
<meta name="generator" content="pdoc 0.10.0" />
<title>neuroconnect.monte_carlo API documentation</title>
<meta name="description" content="General monte carlo simulation helper." />
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/sanitize.min.css" integrity="sha256-PK9q560IAAa6WVRRh76LtCaI8pjTJ2z11v0miyNNjrs=" crossorigin>
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/typography.min.css" integrity="sha256-7l/o7C8jubJiy74VsKTidCy1yBkRtiUGbVkYBylBqUg=" crossorigin>
<link rel="stylesheet preload" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/styles/github.min.css" crossorigin>
<style>:root{--highlight-color:#fe9}.flex{display:flex !important}body{line-height:1.5em}#content{padding:20px}#sidebar{padding:30px;overflow:hidden}#sidebar > *:last-child{margin-bottom:2cm}.http-server-breadcrumbs{font-size:130%;margin:0 0 15px 0}#footer{font-size:.75em;padding:5px 30px;border-top:1px solid #ddd;text-align:right}#footer p{margin:0 0 0 1em;display:inline-block}#footer p:last-child{margin-right:30px}h1,h2,h3,h4,h5{font-weight:300}h1{font-size:2.5em;line-height:1.1em}h2{font-size:1.75em;margin:1em 0 .50em 0}h3{font-size:1.4em;margin:25px 0 10px 0}h4{margin:0;font-size:105%}h1:target,h2:target,h3:target,h4:target,h5:target,h6:target{background:var(--highlight-color);padding:.2em 0}a{color:#058;text-decoration:none;transition:color .3s ease-in-out}a:hover{color:#e82}.title code{font-weight:bold}h2[id^="header-"]{margin-top:2em}.ident{color:#900}pre code{background:#f8f8f8;font-size:.8em;line-height:1.4em}code{background:#f2f2f1;padding:1px 4px;overflow-wrap:break-word}h1 code{background:transparent}pre{background:#f8f8f8;border:0;border-top:1px solid #ccc;border-bottom:1px solid #ccc;margin:1em 0;padding:1ex}#http-server-module-list{display:flex;flex-flow:column}#http-server-module-list div{display:flex}#http-server-module-list dt{min-width:10%}#http-server-module-list p{margin-top:0}.toc ul,#index{list-style-type:none;margin:0;padding:0}#index code{background:transparent}#index h3{border-bottom:1px solid #ddd}#index ul{padding:0}#index h4{margin-top:.6em;font-weight:bold}@media (min-width:200ex){#index .two-column{column-count:2}}@media (min-width:300ex){#index .two-column{column-count:3}}dl{margin-bottom:2em}dl dl:last-child{margin-bottom:4em}dd{margin:0 0 1em 3em}#header-classes + dl > dd{margin-bottom:3em}dd dd{margin-left:2em}dd p{margin:10px 0}.name{background:#eee;font-weight:bold;font-size:.85em;padding:5px 10px;display:inline-block;min-width:40%}.name:hover{background:#e0e0e0}dt:target .name{background:var(--highlight-color)}.name > span:first-child{white-space:nowrap}.name.class > span:nth-child(2){margin-left:.4em}.inherited{color:#999;border-left:5px solid #eee;padding-left:1em}.inheritance em{font-style:normal;font-weight:bold}.desc h2{font-weight:400;font-size:1.25em}.desc h3{font-size:1em}.desc dt code{background:inherit}.source summary,.git-link-div{color:#666;text-align:right;font-weight:400;font-size:.8em;text-transform:uppercase}.source summary > *{white-space:nowrap;cursor:pointer}.git-link{color:inherit;margin-left:1em}.source pre{max-height:500px;overflow:auto;margin:0}.source pre code{font-size:12px;overflow:visible}.hlist{list-style:none}.hlist li{display:inline}.hlist li:after{content:',\2002'}.hlist li:last-child:after{content:none}.hlist .hlist{display:inline;padding-left:1em}img{max-width:100%}td{padding:0 .5em}.admonition{padding:.1em .5em;margin-bottom:1em}.admonition-title{font-weight:bold}.admonition.note,.admonition.info,.admonition.important{background:#aef}.admonition.todo,.admonition.versionadded,.admonition.tip,.admonition.hint{background:#dfd}.admonition.warning,.admonition.versionchanged,.admonition.deprecated{background:#fd4}.admonition.error,.admonition.danger,.admonition.caution{background:lightpink}</style>
<style media="screen and (min-width: 700px)">@media screen and (min-width:700px){#sidebar{width:30%;height:100vh;overflow:auto;position:sticky;top:0}#content{width:70%;max-width:100ch;padding:3em 4em;border-left:1px solid #ddd}pre code{font-size:1em}.item .name{font-size:1em}main{display:flex;flex-direction:row-reverse;justify-content:flex-end}.toc ul ul,#index ul{padding-left:1.5em}.toc > ul > li{margin-top:.5em}}</style>
<style media="print">@media print{#sidebar h1{page-break-before:always}.source{display:none}}@media print{*{background:transparent !important;color:#000 !important;box-shadow:none !important;text-shadow:none !important}a[href]:after{content:" (" attr(href) ")";font-size:90%}a[href][title]:after{content:none}abbr[title]:after{content:" (" attr(title) ")"}.ir a:after,a[href^="javascript:"]:after,a[href^="#"]:after{content:""}pre,blockquote{border:1px solid #999;page-break-inside:avoid}thead{display:table-header-group}tr,img{page-break-inside:avoid}img{max-width:100% !important}@page{margin:0.5cm}p,h2,h3{orphans:3;widows:3}h1,h2,h3,h4,h5,h6{page-break-after:avoid}}</style>
<script defer src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/highlight.min.js" integrity="sha256-Uv3H6lx7dJmRfRvH8TH6kJD1TSK1aFcwgx+mdg3epi8=" crossorigin></script>
<script>window.addEventListener('DOMContentLoaded', () => hljs.initHighlighting())</script>
</head>
<body>
<main>
<article id="content">
<header>
<h1 class="title">Module <code>neuroconnect.monte_carlo</code></h1>
</header>
<section id="section-intro">
<p>General monte carlo simulation helper.</p>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">&#34;&#34;&#34;General monte carlo simulation helper.&#34;&#34;&#34;

import os
from time import time
import multiprocessing
from collections import OrderedDict

from pathos.multiprocessing import ProcessPool
import pandas as pd
import seaborn as sns
import matplotlib.pyplot as plt
from tqdm import tqdm
from mpmath import mpf

global_fn_multi = None
global_var_multi = None


def multiprocessing_func(fn_to_eval, random_var_gen, i):
    &#34;&#34;&#34;Allows monte carlo to run on multiple CPUs.&#34;&#34;&#34;
    random_vars = random_var_gen(i)
    result = fn_to_eval(*random_vars)
    return result


def monte_carlo(
    fn_to_eval,
    random_var_gen,
    num_simulations,
    num_cpus=1,
    save_every=1,
    save_name=&#34;monte_carlo_result.csv&#34;,
    headers=None,
    progress=True,
):
    &#34;&#34;&#34;
    Full monte carlo simulation loop.

    Evaluate fn_to_eval over num_simulations iterations, with
    *random_var_gen(i) passed into fn_to_eval at each iteration i.

    &#34;&#34;&#34;
    all_stats = []
    global_fn_multi = fn_to_eval
    global_var_multi = random_var_gen
    save_every = int(save_every * num_simulations)

    # temp = [random_var_gen() for _ in range(num_simulations)]
    # random_vars = [[] for _ in temp[0]]
    # for val in temp:
    #     for i, item in enumerate(val):
    #         random_vars[i].append(item)

    pbar = tqdm(range(num_simulations), disable=not progress)
    if num_cpus &gt; 1:
        # pool = multiprocessing.get_context(&#34;spawn&#34;).Pool(num_cpus)
        pool = ProcessPool(nodes=num_cpus)
        print(
            &#34;Launching {} workers for {} iterations&#34;.format(num_cpus, num_simulations)
        )
        pbar.set_description(&#34;Monte carlo loop&#34;)
        for i in pbar:
            result = pool.apipe(
                multiprocessing_func, global_fn_multi, global_var_multi, i
            )
            # result = pool.amap(fn_to_eval, random_vars)
            # result = pool.apply_async(
            #     multiprocessing_func,
            #     (i, global_fn_multi, global_var_multi))
            all_stats.append(result.get())

    else:
        pbar.set_description(&#34;Monte carlo loop&#34;)
        for i in pbar:
            random_vars = random_var_gen(i)
            result = fn_to_eval(*random_vars)
            all_stats.append(result)

            if (i != 0) and (i % save_every == 0):
                parts = os.path.splitext(save_name)
                out_name = parts[0] + &#34;_&#34; + str(i) + parts[1]
                df = list_to_df(all_stats, headers)
                here = os.path.dirname(os.path.realpath(__file__))
                os.makedirs(os.path.join(here, &#34;..&#34;, &#34;mc&#34;), exist_ok=True)
                print(&#34;Saving results at {} iterations to {}&#34;.format(i, out_name))
                df.to_csv(os.path.join(here, &#34;..&#34;, &#34;mc&#34;, out_name), index=False)

    return all_stats


def list_to_df(in_list, headers=None):
    &#34;&#34;&#34;Convert a list to a dataframe with the given headers.&#34;&#34;&#34;
    if headers is None:
        headers = [&#34;V{}&#34;.format(i) for i in range(len(in_list[0]))]
    results_df = pd.DataFrame.from_records(in_list, columns=headers)
    return results_df


def summarise_monte_carlo(
    df,
    txt_outfile=None,
    plot=True,
    to_plot=None,
    plt_outfile=None,
    do_print=False,
):
    &#34;&#34;&#34;Summary stats of monte carlo with optional dist plot.&#34;&#34;&#34;
    result = df.describe().round(4)
    if (txt_outfile is None) and do_print:
        print(result)
    elif txt_outfile is not None:
        with open(txt_outfile, &#34;w&#34;) as f:
            f.write(result)
    if plot:
        if to_plot is None:
            raise ValueError(&#34;Please provide a column to plot&#34;)
        a = df[to_plot].to_numpy()
        is_unique = (a[0] == a).all()
        if not is_unique:
            sns.displot(
                df[to_plot],
                kde=True,
                rug=False,
                # kde_kws={&#34;color&#34;: &#34;k&#34;, &#34;lw&#34;: 3, &#34;label&#34;: &#34;KDE&#34;},
                # hist_kws={&#34;histtype&#34;: &#34;step&#34;, &#34;linewidth&#34;: 3, &#34;alpha&#34;: 1, &#34;color&#34;: &#34;g&#34;},
            )
            if plt_outfile is None:
                plt.show()
            else:
                plt.savefig(plt_outfile, dpi=400)
        plt.close()
    return result


def get_distribution(result_df, column_name, num_iters):
    &#34;&#34;&#34;Calculate the simulated distribution of column_name.&#34;&#34;&#34;
    distrib = {}
    to_add = 1 / num_iters
    for val in result_df[column_name]:
        if val in distrib:
            distrib[val] += to_add
        else:
            distrib[val] = to_add

    ordered_dist = OrderedDict()
    keys = sorted(distrib.keys())
    for key in keys:
        ordered_dist[key] = distrib[key]

    return ordered_dist


def dist_difference(actual_distribution, expected_distribution):
    &#34;&#34;&#34;Calculate the difference between two distributions.&#34;&#34;&#34;
    difference = {}
    for k, v in expected_distribution.items():
        difference[k] = actual_distribution[k] - v
    return difference</code></pre>
</details>
</section>
<section>
</section>
<section>
</section>
<section>
<h2 class="section-title" id="header-functions">Functions</h2>
<dl>
<dt id="neuroconnect.monte_carlo.dist_difference"><code class="name flex">
<span>def <span class="ident">dist_difference</span></span>(<span>actual_distribution, expected_distribution)</span>
</code></dt>
<dd>
<div class="desc"><p>Calculate the difference between two distributions.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def dist_difference(actual_distribution, expected_distribution):
    &#34;&#34;&#34;Calculate the difference between two distributions.&#34;&#34;&#34;
    difference = {}
    for k, v in expected_distribution.items():
        difference[k] = actual_distribution[k] - v
    return difference</code></pre>
</details>
</dd>
<dt id="neuroconnect.monte_carlo.get_distribution"><code class="name flex">
<span>def <span class="ident">get_distribution</span></span>(<span>result_df, column_name, num_iters)</span>
</code></dt>
<dd>
<div class="desc"><p>Calculate the simulated distribution of column_name.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_distribution(result_df, column_name, num_iters):
    &#34;&#34;&#34;Calculate the simulated distribution of column_name.&#34;&#34;&#34;
    distrib = {}
    to_add = 1 / num_iters
    for val in result_df[column_name]:
        if val in distrib:
            distrib[val] += to_add
        else:
            distrib[val] = to_add

    ordered_dist = OrderedDict()
    keys = sorted(distrib.keys())
    for key in keys:
        ordered_dist[key] = distrib[key]

    return ordered_dist</code></pre>
</details>
</dd>
<dt id="neuroconnect.monte_carlo.list_to_df"><code class="name flex">
<span>def <span class="ident">list_to_df</span></span>(<span>in_list, headers=None)</span>
</code></dt>
<dd>
<div class="desc"><p>Convert a list to a dataframe with the given headers.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def list_to_df(in_list, headers=None):
    &#34;&#34;&#34;Convert a list to a dataframe with the given headers.&#34;&#34;&#34;
    if headers is None:
        headers = [&#34;V{}&#34;.format(i) for i in range(len(in_list[0]))]
    results_df = pd.DataFrame.from_records(in_list, columns=headers)
    return results_df</code></pre>
</details>
</dd>
<dt id="neuroconnect.monte_carlo.monte_carlo"><code class="name flex">
<span>def <span class="ident">monte_carlo</span></span>(<span>fn_to_eval, random_var_gen, num_simulations, num_cpus=1, save_every=1, save_name='monte_carlo_result.csv', headers=None, progress=True)</span>
</code></dt>
<dd>
<div class="desc"><p>Full monte carlo simulation loop.</p>
<p>Evaluate fn_to_eval over num_simulations iterations, with
*random_var_gen(i) passed into fn_to_eval at each iteration i.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def monte_carlo(
    fn_to_eval,
    random_var_gen,
    num_simulations,
    num_cpus=1,
    save_every=1,
    save_name=&#34;monte_carlo_result.csv&#34;,
    headers=None,
    progress=True,
):
    &#34;&#34;&#34;
    Full monte carlo simulation loop.

    Evaluate fn_to_eval over num_simulations iterations, with
    *random_var_gen(i) passed into fn_to_eval at each iteration i.

    &#34;&#34;&#34;
    all_stats = []
    global_fn_multi = fn_to_eval
    global_var_multi = random_var_gen
    save_every = int(save_every * num_simulations)

    # temp = [random_var_gen() for _ in range(num_simulations)]
    # random_vars = [[] for _ in temp[0]]
    # for val in temp:
    #     for i, item in enumerate(val):
    #         random_vars[i].append(item)

    pbar = tqdm(range(num_simulations), disable=not progress)
    if num_cpus &gt; 1:
        # pool = multiprocessing.get_context(&#34;spawn&#34;).Pool(num_cpus)
        pool = ProcessPool(nodes=num_cpus)
        print(
            &#34;Launching {} workers for {} iterations&#34;.format(num_cpus, num_simulations)
        )
        pbar.set_description(&#34;Monte carlo loop&#34;)
        for i in pbar:
            result = pool.apipe(
                multiprocessing_func, global_fn_multi, global_var_multi, i
            )
            # result = pool.amap(fn_to_eval, random_vars)
            # result = pool.apply_async(
            #     multiprocessing_func,
            #     (i, global_fn_multi, global_var_multi))
            all_stats.append(result.get())

    else:
        pbar.set_description(&#34;Monte carlo loop&#34;)
        for i in pbar:
            random_vars = random_var_gen(i)
            result = fn_to_eval(*random_vars)
            all_stats.append(result)

            if (i != 0) and (i % save_every == 0):
                parts = os.path.splitext(save_name)
                out_name = parts[0] + &#34;_&#34; + str(i) + parts[1]
                df = list_to_df(all_stats, headers)
                here = os.path.dirname(os.path.realpath(__file__))
                os.makedirs(os.path.join(here, &#34;..&#34;, &#34;mc&#34;), exist_ok=True)
                print(&#34;Saving results at {} iterations to {}&#34;.format(i, out_name))
                df.to_csv(os.path.join(here, &#34;..&#34;, &#34;mc&#34;, out_name), index=False)

    return all_stats</code></pre>
</details>
</dd>
<dt id="neuroconnect.monte_carlo.multiprocessing_func"><code class="name flex">
<span>def <span class="ident">multiprocessing_func</span></span>(<span>fn_to_eval, random_var_gen, i)</span>
</code></dt>
<dd>
<div class="desc"><p>Allows monte carlo to run on multiple CPUs.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def multiprocessing_func(fn_to_eval, random_var_gen, i):
    &#34;&#34;&#34;Allows monte carlo to run on multiple CPUs.&#34;&#34;&#34;
    random_vars = random_var_gen(i)
    result = fn_to_eval(*random_vars)
    return result</code></pre>
</details>
</dd>
<dt id="neuroconnect.monte_carlo.summarise_monte_carlo"><code class="name flex">
<span>def <span class="ident">summarise_monte_carlo</span></span>(<span>df, txt_outfile=None, plot=True, to_plot=None, plt_outfile=None, do_print=False)</span>
</code></dt>
<dd>
<div class="desc"><p>Summary stats of monte carlo with optional dist plot.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def summarise_monte_carlo(
    df,
    txt_outfile=None,
    plot=True,
    to_plot=None,
    plt_outfile=None,
    do_print=False,
):
    &#34;&#34;&#34;Summary stats of monte carlo with optional dist plot.&#34;&#34;&#34;
    result = df.describe().round(4)
    if (txt_outfile is None) and do_print:
        print(result)
    elif txt_outfile is not None:
        with open(txt_outfile, &#34;w&#34;) as f:
            f.write(result)
    if plot:
        if to_plot is None:
            raise ValueError(&#34;Please provide a column to plot&#34;)
        a = df[to_plot].to_numpy()
        is_unique = (a[0] == a).all()
        if not is_unique:
            sns.displot(
                df[to_plot],
                kde=True,
                rug=False,
                # kde_kws={&#34;color&#34;: &#34;k&#34;, &#34;lw&#34;: 3, &#34;label&#34;: &#34;KDE&#34;},
                # hist_kws={&#34;histtype&#34;: &#34;step&#34;, &#34;linewidth&#34;: 3, &#34;alpha&#34;: 1, &#34;color&#34;: &#34;g&#34;},
            )
            if plt_outfile is None:
                plt.show()
            else:
                plt.savefig(plt_outfile, dpi=400)
        plt.close()
    return result</code></pre>
</details>
</dd>
</dl>
</section>
<section>
</section>
</article>
<nav id="sidebar">
<h1>Index</h1>
<div class="toc">
<ul></ul>
</div>
<ul id="index">
<li><h3>Super-module</h3>
<ul>
<li><code><a title="neuroconnect" href="index.html">neuroconnect</a></code></li>
</ul>
</li>
<li><h3><a href="#header-functions">Functions</a></h3>
<ul class="">
<li><code><a title="neuroconnect.monte_carlo.dist_difference" href="#neuroconnect.monte_carlo.dist_difference">dist_difference</a></code></li>
<li><code><a title="neuroconnect.monte_carlo.get_distribution" href="#neuroconnect.monte_carlo.get_distribution">get_distribution</a></code></li>
<li><code><a title="neuroconnect.monte_carlo.list_to_df" href="#neuroconnect.monte_carlo.list_to_df">list_to_df</a></code></li>
<li><code><a title="neuroconnect.monte_carlo.monte_carlo" href="#neuroconnect.monte_carlo.monte_carlo">monte_carlo</a></code></li>
<li><code><a title="neuroconnect.monte_carlo.multiprocessing_func" href="#neuroconnect.monte_carlo.multiprocessing_func">multiprocessing_func</a></code></li>
<li><code><a title="neuroconnect.monte_carlo.summarise_monte_carlo" href="#neuroconnect.monte_carlo.summarise_monte_carlo">summarise_monte_carlo</a></code></li>
</ul>
</li>
</ul>
</nav>
</main>
<footer id="footer">
<p>Generated by <a href="https://pdoc3.github.io/pdoc" title="pdoc: Python API documentation generator"><cite>pdoc</cite> 0.10.0</a>.</p>
</footer>
</body>
</html>