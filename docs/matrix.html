<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1, minimum-scale=1" />
<meta name="generator" content="pdoc 0.10.0" />
<title>neuroconnect.matrix API documentation</title>
<meta name="description" content="This module handles experiments related to matrix connections." />
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/sanitize.min.css" integrity="sha256-PK9q560IAAa6WVRRh76LtCaI8pjTJ2z11v0miyNNjrs=" crossorigin>
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/typography.min.css" integrity="sha256-7l/o7C8jubJiy74VsKTidCy1yBkRtiUGbVkYBylBqUg=" crossorigin>
<link rel="stylesheet preload" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/styles/github.min.css" crossorigin>
<style>:root{--highlight-color:#fe9}.flex{display:flex !important}body{line-height:1.5em}#content{padding:20px}#sidebar{padding:30px;overflow:hidden}#sidebar > *:last-child{margin-bottom:2cm}.http-server-breadcrumbs{font-size:130%;margin:0 0 15px 0}#footer{font-size:.75em;padding:5px 30px;border-top:1px solid #ddd;text-align:right}#footer p{margin:0 0 0 1em;display:inline-block}#footer p:last-child{margin-right:30px}h1,h2,h3,h4,h5{font-weight:300}h1{font-size:2.5em;line-height:1.1em}h2{font-size:1.75em;margin:1em 0 .50em 0}h3{font-size:1.4em;margin:25px 0 10px 0}h4{margin:0;font-size:105%}h1:target,h2:target,h3:target,h4:target,h5:target,h6:target{background:var(--highlight-color);padding:.2em 0}a{color:#058;text-decoration:none;transition:color .3s ease-in-out}a:hover{color:#e82}.title code{font-weight:bold}h2[id^="header-"]{margin-top:2em}.ident{color:#900}pre code{background:#f8f8f8;font-size:.8em;line-height:1.4em}code{background:#f2f2f1;padding:1px 4px;overflow-wrap:break-word}h1 code{background:transparent}pre{background:#f8f8f8;border:0;border-top:1px solid #ccc;border-bottom:1px solid #ccc;margin:1em 0;padding:1ex}#http-server-module-list{display:flex;flex-flow:column}#http-server-module-list div{display:flex}#http-server-module-list dt{min-width:10%}#http-server-module-list p{margin-top:0}.toc ul,#index{list-style-type:none;margin:0;padding:0}#index code{background:transparent}#index h3{border-bottom:1px solid #ddd}#index ul{padding:0}#index h4{margin-top:.6em;font-weight:bold}@media (min-width:200ex){#index .two-column{column-count:2}}@media (min-width:300ex){#index .two-column{column-count:3}}dl{margin-bottom:2em}dl dl:last-child{margin-bottom:4em}dd{margin:0 0 1em 3em}#header-classes + dl > dd{margin-bottom:3em}dd dd{margin-left:2em}dd p{margin:10px 0}.name{background:#eee;font-weight:bold;font-size:.85em;padding:5px 10px;display:inline-block;min-width:40%}.name:hover{background:#e0e0e0}dt:target .name{background:var(--highlight-color)}.name > span:first-child{white-space:nowrap}.name.class > span:nth-child(2){margin-left:.4em}.inherited{color:#999;border-left:5px solid #eee;padding-left:1em}.inheritance em{font-style:normal;font-weight:bold}.desc h2{font-weight:400;font-size:1.25em}.desc h3{font-size:1em}.desc dt code{background:inherit}.source summary,.git-link-div{color:#666;text-align:right;font-weight:400;font-size:.8em;text-transform:uppercase}.source summary > *{white-space:nowrap;cursor:pointer}.git-link{color:inherit;margin-left:1em}.source pre{max-height:500px;overflow:auto;margin:0}.source pre code{font-size:12px;overflow:visible}.hlist{list-style:none}.hlist li{display:inline}.hlist li:after{content:',\2002'}.hlist li:last-child:after{content:none}.hlist .hlist{display:inline;padding-left:1em}img{max-width:100%}td{padding:0 .5em}.admonition{padding:.1em .5em;margin-bottom:1em}.admonition-title{font-weight:bold}.admonition.note,.admonition.info,.admonition.important{background:#aef}.admonition.todo,.admonition.versionadded,.admonition.tip,.admonition.hint{background:#dfd}.admonition.warning,.admonition.versionchanged,.admonition.deprecated{background:#fd4}.admonition.error,.admonition.danger,.admonition.caution{background:lightpink}</style>
<style media="screen and (min-width: 700px)">@media screen and (min-width:700px){#sidebar{width:30%;height:100vh;overflow:auto;position:sticky;top:0}#content{width:70%;max-width:100ch;padding:3em 4em;border-left:1px solid #ddd}pre code{font-size:1em}.item .name{font-size:1em}main{display:flex;flex-direction:row-reverse;justify-content:flex-end}.toc ul ul,#index ul{padding-left:1.5em}.toc > ul > li{margin-top:.5em}}</style>
<style media="print">@media print{#sidebar h1{page-break-before:always}.source{display:none}}@media print{*{background:transparent !important;color:#000 !important;box-shadow:none !important;text-shadow:none !important}a[href]:after{content:" (" attr(href) ")";font-size:90%}a[href][title]:after{content:none}abbr[title]:after{content:" (" attr(title) ")"}.ir a:after,a[href^="javascript:"]:after,a[href^="#"]:after{content:""}pre,blockquote{border:1px solid #999;page-break-inside:avoid}thead{display:table-header-group}tr,img{page-break-inside:avoid}img{max-width:100% !important}@page{margin:0.5cm}p,h2,h3{orphans:3;widows:3}h1,h2,h3,h4,h5,h6{page-break-after:avoid}}</style>
<script defer src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/highlight.min.js" integrity="sha256-Uv3H6lx7dJmRfRvH8TH6kJD1TSK1aFcwgx+mdg3epi8=" crossorigin></script>
<script>window.addEventListener('DOMContentLoaded', () => hljs.initHighlighting())</script>
</head>
<body>
<main>
<article id="content">
<header>
<h1 class="title">Module <code>neuroconnect.matrix</code></h1>
</header>
<section id="section-intro">
<p>This module handles experiments related to matrix connections.</p>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">&#34;&#34;&#34;This module handles experiments related to matrix connections.&#34;&#34;&#34;

import os
import gc
import numpy as np
from collections import OrderedDict
from pprint import pprint
import pickle

from scipy import sparse
from mpmath import mpf
import pandas as pd

from .connectivity_patterns import MatrixConnectivity
from .simple_graph import find_connected_limited
from .mpf_connection import CombProb
from .monte_carlo import (
    monte_carlo,
    list_to_df,
    summarise_monte_carlo,
    get_distribution,
    dist_difference,
)
from .connect_math import get_dist_mean, get_dist_var
from .nx_graph import nx_create_graph, nx_vis_force
from .simple_graph import matrix_vis, reverse

here = os.path.dirname(os.path.realpath(__file__))
pickle_loc = os.path.abspath(os.path.join(here, &#34;..&#34;, &#34;resources&#34;, &#34;graph.pickle&#34;))


def convert_mouse_data(A_name, B_name, hemisphere=&#34;right&#34;):
    &#34;&#34;&#34;Convert general blue brain data into smaller data.&#34;&#34;&#34;
    here = os.path.dirname(os.path.realpath(__file__))
    if hemisphere == &#34;right&#34;:
        resource_dir = os.path.join(here, &#34;..&#34;, &#34;resources&#34;, &#34;right_hemisphere&#34;)
    elif hemisphere == &#34;left&#34;:
        resource_dir = os.path.join(here, &#34;..&#34;, &#34;resources&#34;, &#34;left_hemisphere&#34;)

    def load_name(name):
        return os.path.join(resource_dir, name)

    def save_name(name):
        return os.path.join(resource_dir, name + &#34;.npz&#34;)

    if os.path.isfile(
        os.path.join(resource_dir, &#34;{}_to_{}.npz&#34;.format(A_name, B_name))
    ):
        print(f&#34;Already converted this mouse data for {hemisphere} hemisphere&#34;)
        return
    print(&#34;Pulling out data from the mouse connectome&#34;)

    end_bit_indices = &#34;_ALL_INPUTS_ipsi.indices.npy&#34;
    end_bit_out = &#34;_ALL_INPUTS_ipsi.csc.npz&#34;
    end_bit_local = &#34;_ALL_INPUTS_local.csc.npz&#34;

    # Load the relevant data
    A_indices = np.load(load_name(A_name + end_bit_indices))
    B_indices = np.load(load_name(B_name + end_bit_indices))

    A_local = sparse.load_npz(load_name(A_name + end_bit_local))
    # In case some stray indices are left around
    A_small = A_local[A_indices]
    sparse.save_npz(save_name(A_name + &#34;_local&#34;), A_small)

    B_local = sparse.load_npz(load_name(B_name + end_bit_local))
    # In case some stray indices are left around
    B_small = B_local[B_indices]
    sparse.save_npz(save_name(B_name + &#34;_local&#34;), B_small)

    A = sparse.load_npz(load_name(A_name + end_bit_out))
    B_to_A = A[B_indices]
    sparse.save_npz(save_name(B_name + &#34;_to_&#34; + A_name), B_to_A)

    B = sparse.load_npz(load_name(B_name + end_bit_out))
    A_to_B = B[A_indices]
    sparse.save_npz(save_name(A_name + &#34;_to_&#34; + B_name), A_to_B)

    return


def load_matrix_data(to_use, A_name, B_name, hemisphere=&#34;right&#34;):
    &#34;&#34;&#34;
    Load matrix data into a connectivity object.

    Parameters
    ----------
    to_use : list of bool
        Which matrices to consider, in the order [ab, ba, aa, bb]

    &#34;&#34;&#34;
    here = os.path.dirname(os.path.realpath(__file__))
    if hemisphere == &#34;right&#34;:
        resource_dir = os.path.join(here, &#34;..&#34;, &#34;resources&#34;, &#34;right_hemisphere&#34;)
    elif hemisphere == &#34;left&#34;:
        resource_dir = os.path.join(here, &#34;..&#34;, &#34;resources&#34;, &#34;left_hemisphere&#34;)

    mc = MatrixConnectivity(
        ab=os.path.join(resource_dir, &#34;{}_to_{}.npz&#34;.format(A_name, B_name)),
        ba=os.path.join(resource_dir, &#34;{}_to_{}.npz&#34;.format(B_name, A_name)),
        aa=os.path.join(resource_dir, &#34;{}_local.npz&#34;.format(A_name)),
        bb=os.path.join(resource_dir, &#34;{}_local.npz&#34;.format(B_name)),
        to_use=to_use,
    )
    args_dict = mc.compute_stats()

    return mc, args_dict


def mpf_connectome(
    mc, num_sampled, max_depth, args_dict, clt_start=10, sr=0.01, mean_estimate=False
):
    &#34;&#34;&#34;Perform mpf statistical calculations on the mouse connectome.&#34;&#34;&#34;
    args_dict[&#34;max_depth&#34;] = max_depth
    args_dict[&#34;total_samples&#34;] = num_sampled[0]
    args_dict[&#34;static_verbose&#34;] = False
    args_dict[&#34;clt_start&#34;] = clt_start
    args_dict[&#34;mean_estimate&#34;] = mean_estimate

    if max_depth &gt; 1:
        sr = None
    if mean_estimate is True:
        sr = None

    cp = CombProb(
        mc.num_a,
        num_sampled[0],
        mc.num_senders,
        mc.num_b,
        num_sampled[1],
        MatrixConnectivity.static_expected_connections,
        verbose=True,
        subsample_rate=sr,
        **args_dict,
    )
    result = {
        &#34;expected&#34;: cp.expected_connections(),
        &#34;total&#34;: cp.get_all_prob(),
        &#34;each_expected&#34;: {k: cp.expected_total(k) for k in range(num_sampled[0] + 1)},
    }

    return result


def mpf_probe_connectome(
    mc,
    num_sampled,
    a_indices,
    b_indices,
    max_depth,
    args_dict,
    clt_start=10,
    sr=0.01,
    mean_estimate=False,
    force_no_mean=False,
):
    &#34;&#34;&#34;Perform mpf statistical calculations on the mouse connectome with a probe.&#34;&#34;&#34;
    probe_stats = mc.compute_probe_stats(
        a_indices,
        b_indices,
    )
    sub_mc = probe_stats[&#34;probes&#34;]
    sub_args_dict = probe_stats[&#34;stats&#34;]
    for k, v in sub_args_dict.items():
        args_dict[f&#34;{k}_probe&#34;] = v
    sub_args_dict = probe_stats[&#34;A_stats&#34;]
    for k, v in sub_args_dict.items():
        args_dict[f&#34;{k}_A&#34;] = v
    sub_args_dict = probe_stats[&#34;B_stats&#34;]
    for k, v in sub_args_dict.items():
        args_dict[f&#34;{k}_B&#34;] = v
    sub_args_dict = probe_stats[&#34;inter&#34;]
    for k, v in sub_args_dict.items():
        args_dict[k] = v

    args_dict[&#34;max_depth&#34;] = max_depth
    args_dict[&#34;total_samples&#34;] = num_sampled[0]
    args_dict[&#34;static_verbose&#34;] = False
    args_dict[&#34;clt_start&#34;] = clt_start
    args_dict[&#34;mean_estimate&#34;] = mean_estimate

    if force_no_mean:
        args_dict[&#34;use_mean&#34;] = False

    if max_depth &gt; 1:
        sr = None
    if mean_estimate is True:
        sr = None

    # This comb prob is for depth =-1
    # If you call senders dist it only works for dpeth = 1
    # Inside of the detla function static_expected_connections
    # Ti instead works correctly for dpth != 1
    cp = CombProb(
        sub_mc.num_a,
        num_sampled[0],
        sub_mc.num_senders,
        sub_mc.num_b,
        num_sampled[1],
        MatrixConnectivity.static_expected_connections,
        verbose=True,
        subsample_rate=sr,
        **args_dict,
    )
    result = {
        &#34;expected&#34;: cp.expected_connections(),
        &#34;total&#34;: cp.get_all_prob(),
        &#34;each_expected&#34;: {k: cp.expected_total(k) for k in range(num_sampled[0] + 1)},
    }

    return result


def handle_pickle(data, name, mode):
    &#34;&#34;&#34;Save or load data to a pickle file.&#34;&#34;&#34;
    pickle_name = os.path.join(os.path.dirname(pickle_loc), name)
    if mode == &#34;w&#34;:
        with open(pickle_name, &#34;wb&#34;) as handle:
            pickle.dump(data, handle, protocol=pickle.HIGHEST_PROTOCOL)
        return None

    if mode == &#34;r&#34;:
        with open(pickle_name, &#34;rb&#34;) as handle:
            b = pickle.load(handle)
        return b


def graph_connectome(
    num_sampled,
    max_depth,
    num_iters=10,
    graph=None,
    reverse_graph=None,
    to_write=None,
    num_cpus=1,
    a_indices=None,
    b_indices=None,
):
    &#34;&#34;&#34;Perform monte carlo graph simulations on the mouse connectome.&#34;&#34;&#34;
    num_a, num_b = to_write

    if a_indices is None:
        a_indices = np.array([i for i in range(num_a)])
    if b_indices is None:
        b_indices = np.array([i for i in range(num_b)])

    def random_var_gen(iter_val):
        start = np.random.choice(a_indices, size=num_sampled[0], replace=False)
        end = np.random.choice(b_indices, size=num_sampled[1], replace=False)
        end = end + num_a

        return start, end

    def fn_to_eval(start, end):
        return (
            len(find_connected_limited(graph, start, end, max_depth, reverse_graph)),
        )

    result = monte_carlo(fn_to_eval, random_var_gen, num_iters, num_cpus=num_cpus)
    df = list_to_df(
        result,
        [&#34;Connections&#34;],
    )
    result = summarise_monte_carlo(
        df,
        plot=False,
    )
    ordered_dist = get_distribution(df, &#34;Connections&#34;, num_iters)

    return {
        &#34;full_results&#34;: df,
        &#34;summary_stats&#34;: result,
        &#34;dist&#34;: ordered_dist,
    }


def print_args_dict(args_dict, out=True):
    to_print = {}
    for v in (&#34;N&#34;, &#34;num_start&#34;, &#34;num_senders&#34;, &#34;num_recurrent&#34;):
        to_print[v] = args_dict[v]
    for v in (
        &#34;out_connections_dist&#34;,
        &#34;recurrent_connections_dist&#34;,
        &#34;start_inter_dist&#34;,
        &#34;end_inter_dist&#34;,
    ):
        to_print[v] = (get_dist_mean(args_dict[v]), get_dist_var(args_dict[v]))

    if out:
        print(to_print)

    return to_print


def check_stats(mc, div_ratio, max_depth, num_iters=1000, num_cpus=1, plot=False):
    &#34;&#34;&#34;Compare the results from simulations and stats.&#34;&#34;&#34;
    a_samples, b_samples = (int(mc.num_a / div_ratio), int(mc.num_b / div_ratio))
    div = (30, 10)  # num_samples / x per region
    new_mc = mc.subsample(a_samples, b_samples)
    new_mc.create_connections()
    args_dict = new_mc.compute_stats()
    print_args_dict(args_dict, out=True)

    num_samples = np.ceil([a_samples / div[0], b_samples / div[1]]).astype(np.int32)
    print(&#34;Sampling {}&#34;.format(num_samples))

    if plot:
        nx_graph = nx_create_graph(new_mc.graph)
        start, end = new_mc.gen_random_samples(num_samples, zeroed=False)
        os.makedirs(os.path.join(here, &#34;..&#34;, &#34;figures&#34;), exist_ok=True)
        nx_vis_force(
            nx_graph,
            new_mc.a_indices,
            new_mc.num_a + new_mc.b_indices,
            start,
            end,
            name=os.path.join(here, &#34;..&#34;, &#34;figures&#34;, &#34;mouse_graph_small.png&#34;),
        )

    def random_var_gen(iter_val):
        start, end = new_mc.gen_random_samples(num_samples, zeroed=False)
        return start, end

    def fn_to_eval(start, end):
        reachable = find_connected_limited(
            new_mc.graph, start, end, max_depth=max_depth
        )
        return (len(reachable),)

    # Stats check
    args_dict[&#34;max_depth&#34;] = max_depth
    args_dict[&#34;total_samples&#34;] = num_samples[0]
    args_dict[&#34;static_verbose&#34;] = False
    cp = CombProb(
        new_mc.num_a,
        float(num_samples[0]),
        new_mc.num_senders,
        new_mc.num_b,
        float(num_samples[1]),
        MatrixConnectivity.static_expected_connections,
        verbose=False,
        **args_dict,
    )
    result_mpf = {
        &#34;expected&#34;: cp.expected_connections(),
        &#34;total&#34;: cp.get_all_prob(),
    }

    result = monte_carlo(fn_to_eval, random_var_gen, num_iters, num_cpus=num_cpus)
    df = list_to_df(
        result,
        [&#34;Connections&#34;],
    )
    result = summarise_monte_carlo(
        df,
        plot=False,
    )
    ordered_dist = get_distribution(df, &#34;Connections&#34;, num_iters)

    return {
        &#34;full_results&#34;: df,
        &#34;summary_stats&#34;: result,
        &#34;dist&#34;: ordered_dist,
        &#34;mpf&#34;: result_mpf,
        &#34;difference&#34;: dist_difference(result_mpf[&#34;total&#34;], ordered_dist),
    }


def make_full_matrix(AB, BA, AA, BB):
    &#34;&#34;&#34;Combine separate into one sparse matrix.&#34;&#34;&#34;
    a_size, b_size = AB.shape

    full_mat = sparse.csc_matrix((a_size + b_size, a_size + b_size))
    full_mat[:a_size, :a_size] = AA
    full_mat[:a_size, a_size:] = AB
    full_mat[a_size:, :a_size] = BA
    full_mat[a_size:, a_size:] = BB

    return full_mat


def gen_random_matrix(a_size, b_size, AB_d, BA_d, AA_d, BB_d):
    &#34;&#34;&#34;Generate a full connectivity matrix at random.&#34;&#34;&#34;

    def random_gen(n_samples):
        return np.ones(shape=(n_samples,))

    AB = sparse.random(a_size, b_size, AB_d, data_rvs=random_gen, format=&#34;csr&#34;)
    BA = sparse.random(b_size, a_size, BA_d, data_rvs=random_gen, format=&#34;csr&#34;)
    AA = sparse.random(a_size, a_size, AA_d, data_rvs=random_gen, format=&#34;csr&#34;)
    BB = sparse.random(b_size, b_size, BB_d, data_rvs=random_gen, format=&#34;csr&#34;)

    return AB, BA, AA, BB


def main(
    num_sampled=[3, 3],
    max_depth=2,
    num_iters=1000,
    do_graph=False,
    # These are for checking stats on smaller data
    subsample=False,
    plot=False,
    # Generates a random matrix for comparison
    random=False,
    # Visualise the connection matrix
    vis_connect=False,
    subsample_vis=False,
    # Generate final graphs
    final=False,
    # Analyse
    analyse=False,
    only_exp=False,
    # Which regions are considered here
    # A_name, B_name = &#34;MOp&#34;, &#34;SSP-ll&#34;
    A_name=&#34;VISp&#34;,
    B_name=&#34;VISl&#34;,
    desired_depth=1,
    desired_samples=79,
):
    &#34;&#34;&#34;Load data and perform calculations.&#34;&#34;&#34;
    np.random.seed(42)

    if random:
        AB, BA, AA, BB = gen_random_matrix(150, 50, 0, 0.04, 0, 0.0)
        matrix_vis(AB, BA, AA, BB, 10, name=&#34;test_vis.png&#34;)

    os.makedirs(os.path.dirname(pickle_loc), exist_ok=True)
    convert_mouse_data(A_name, B_name)
    to_use = [True, True, True, True]
    mc, args_dict = load_matrix_data(to_use, A_name, B_name)
    print(&#34;{} - {}, {} - {}&#34;.format(A_name, B_name, mc.num_a, mc.num_b))

    result = {}
    result[&#34;matrix_stats&#34;] = print_args_dict(args_dict, out=False)

    if only_exp:
        mpf_res = mpf_connectome(mc, num_sampled, max_depth, args_dict)
        mpf_val = [
            mpf_res[&#34;expected&#34;],
            mpf_res[&#34;expected&#34;] / num_sampled[1],
            &#34;{}_{}&#34;.format(A_name, B_name),
            &#34;Statistical estimation&#34;,
        ]
        if do_graph:
            print(&#34;Converting matrix&#34;)
            gc.collect()
            mc.create_connections()
            print(&#34;Finished conversion&#34;)
            graph = mc.graph
            to_write = [mc.num_a, mc.num_b]
            del mc
            gc.collect()
            reverse_graph = reverse(graph)
            graph_res = graph_connectome(
                num_sampled,
                max_depth,
                graph=graph,
                reverse_graph=reverse_graph,
                to_write=to_write,
                num_iters=num_iters,
            )
            to_add = np.mean(graph_res[&#34;full_results&#34;][&#34;Connections&#34;].values)
            graph_val = [
                to_add,
                to_add / num_sampled[1],
                &#34;{}_{}&#34;.format(A_name, B_name),
                &#34;Statistical estimation&#34;,
            ]
            return mpf_val, graph_val
        return mpf_val, None

    # Convert to a pickle
    # if not os.path.isfile(pickle_loc):
    #     print(&#34;Converting matrix&#34;)
    #     gc.collect()
    #     mc.create_connections()
    #     print(&#34;Finished conversion&#34;)
    #     graph = mc.graph
    #     to_write = [mc.num_a, mc.num_b]
    #     del mc
    #     gc.collect()

    #     handle_pickle(graph, &#34;graph.pickle&#34;, &#34;w&#34;)
    #     handle_pickle(reverse(graph), &#34;r_graph.pickle&#34;, &#34;w&#34;)
    #     handle_pickle(to_write, &#34;graph_size.pickle&#34;, &#34;w&#34;)

    if vis_connect:
        if subsample_vis:
            print(&#34;Plotting subsampled matrix vis&#34;)
            new_mc = mc.subsample(int(mc.num_a / 10), int(mc.num_b / 10))
            matrix_vis(
                new_mc.ab,
                new_mc.ba,
                new_mc.aa,
                new_mc.bb,
                15,
                name=&#34;mc_mat_vis_sub10.pdf&#34;,
            )
        else:
            o_name = &#34;mc_mat_vis_{}_to_{}.pdf&#34;.format(A_name, B_name)
            print(&#34;Plotting full matrix vis&#34;)
            matrix_vis(mc.ab, mc.ba, mc.aa, mc.bb, 150, name=o_name)
        print(&#34;done vis&#34;)

    print(mc, print_args_dict(args_dict, out=False))

    result = None
    if subsample:
        result = check_stats(mc, 1000, 1, 20000, 1, plot)
    if final:
        result = {}

        # For different depths and number of samples
        for depth in range(1, 4):
            for ns in range(1, num_sampled[0] + 1):
                ns_2 = [ns] * 2
                mpf_res = mpf_connectome(mc, ns_2, depth, args_dict)
                result[&#34;mpf_{}_{}&#34;.format(depth, ns)] = mpf_res

        # Save this for plotting
        cols = [&#34;Number of samples&#34;, &#34;Proportion of connections&#34;, &#34;Max distance&#34;]
        depth_name = [None, &#34;Direct synapse&#34;, &#34;Two synapses&#34;, &#34;Three synapses&#34;]
        vals = []
        for depth in range(1, 4):
            for ns in range(1, num_sampled[0] + 1):
                this = result[&#34;mpf_{}_{}&#34;.format(depth, ns)]
                val = [ns, this[&#34;expected&#34;] / ns, depth_name[depth]]
                vals.append(val)
        df = pd.DataFrame(vals, columns=cols)
        os.makedirs(os.path.join(here, &#34;..&#34;, &#34;results&#34;), exist_ok=True)
        df.to_csv(
            os.path.join(
                here, &#34;..&#34;, &#34;results&#34;, &#34;{}_to_{}_depth.csv&#34;.format(A_name, B_name)
            ),
            index=False,
        )

        cols = [&#34;Number of sampled connected neurons&#34;, &#34;Probability&#34;]
        total_pmf = result[&#34;mpf_{}_{}&#34;.format(desired_depth, desired_samples)][&#34;total&#34;]
        vals = []
        for k, v in total_pmf.items():
            vals.append([k, float(v)])
        df = pd.DataFrame(vals, columns=cols)
        df.to_csv(
            os.path.join(
                here,
                &#34;..&#34;,
                &#34;results&#34;,
                &#34;{}_to_{}_pmf_{}_{}.csv&#34;.format(
                    A_name, B_name, desired_depth, desired_samples
                ),
            ),
            index=False,
        )
    if analyse:
        result = {}
        result[&#34;matrix_stats&#34;] = args_dict

        mpf_res = mpf_connectome(
            mc,
            num_sampled,
            max_depth,
            args_dict,
            clt_start=30,
            sr=None,
            mean_estimate=True,
        )
        result[&#34;mean&#34;] = mpf_res

        vals = []
        cols = [&#34;Number of connected neurons&#34;, &#34;Probability&#34;, &#34;Calculation&#34;]
        for k, v in mpf_res[&#34;total&#34;].items():
            vals.append([k, float(v), &#34;Mean estimation&#34;])

        mpf_res = mpf_connectome(mc, num_sampled, max_depth, args_dict, clt_start=30)
        result[&#34;mpf&#34;] = mpf_res

        for k, v in mpf_res[&#34;total&#34;].items():
            vals.append([k, float(v), &#34;Statistical estimation&#34;])

        if do_graph:
            print(&#34;Converting matrix&#34;)
            gc.collect()
            mc.create_connections()
            print(&#34;Finished conversion&#34;)
            graph = mc.graph
            to_write = [mc.num_a, mc.num_b]
            del mc
            gc.collect()
            reverse_graph = reverse(graph)

            graph_res = graph_connectome(
                num_sampled,
                max_depth,
                graph=graph,
                reverse_graph=reverse_graph,
                to_write=to_write,
                num_iters=num_iters,
            )

            result[&#34;difference&#34;] = (
                dist_difference(mpf_res[&#34;total&#34;], graph_res[&#34;dist&#34;]),
            )
            result[&#34;graph&#34;] = graph_res

            for k, v in graph_res[&#34;dist&#34;].items():
                vals.append([k, float(v), &#34;Monte Carlo simulation&#34;])

        df = pd.DataFrame(vals, columns=cols)
        df.to_csv(
            os.path.join(
                here,
                &#34;..&#34;,
                &#34;results&#34;,
                &#34;{}_to_{}_pmf_final_{}_{}.csv&#34;.format(
                    A_name, B_name, max_depth, num_sampled[0]
                ),
            ),
            index=False,
        )

    if result is not None:
        with open(os.path.join(here, &#34;..&#34;, &#34;results&#34;, &#34;mouse.txt&#34;), &#34;w&#34;) as f:
            pprint(result, width=120, stream=f)

    return result


if __name__ == &#34;__main__&#34;:
    main()</code></pre>
</details>
</section>
<section>
</section>
<section>
</section>
<section>
<h2 class="section-title" id="header-functions">Functions</h2>
<dl>
<dt id="neuroconnect.matrix.check_stats"><code class="name flex">
<span>def <span class="ident">check_stats</span></span>(<span>mc, div_ratio, max_depth, num_iters=1000, num_cpus=1, plot=False)</span>
</code></dt>
<dd>
<div class="desc"><p>Compare the results from simulations and stats.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def check_stats(mc, div_ratio, max_depth, num_iters=1000, num_cpus=1, plot=False):
    &#34;&#34;&#34;Compare the results from simulations and stats.&#34;&#34;&#34;
    a_samples, b_samples = (int(mc.num_a / div_ratio), int(mc.num_b / div_ratio))
    div = (30, 10)  # num_samples / x per region
    new_mc = mc.subsample(a_samples, b_samples)
    new_mc.create_connections()
    args_dict = new_mc.compute_stats()
    print_args_dict(args_dict, out=True)

    num_samples = np.ceil([a_samples / div[0], b_samples / div[1]]).astype(np.int32)
    print(&#34;Sampling {}&#34;.format(num_samples))

    if plot:
        nx_graph = nx_create_graph(new_mc.graph)
        start, end = new_mc.gen_random_samples(num_samples, zeroed=False)
        os.makedirs(os.path.join(here, &#34;..&#34;, &#34;figures&#34;), exist_ok=True)
        nx_vis_force(
            nx_graph,
            new_mc.a_indices,
            new_mc.num_a + new_mc.b_indices,
            start,
            end,
            name=os.path.join(here, &#34;..&#34;, &#34;figures&#34;, &#34;mouse_graph_small.png&#34;),
        )

    def random_var_gen(iter_val):
        start, end = new_mc.gen_random_samples(num_samples, zeroed=False)
        return start, end

    def fn_to_eval(start, end):
        reachable = find_connected_limited(
            new_mc.graph, start, end, max_depth=max_depth
        )
        return (len(reachable),)

    # Stats check
    args_dict[&#34;max_depth&#34;] = max_depth
    args_dict[&#34;total_samples&#34;] = num_samples[0]
    args_dict[&#34;static_verbose&#34;] = False
    cp = CombProb(
        new_mc.num_a,
        float(num_samples[0]),
        new_mc.num_senders,
        new_mc.num_b,
        float(num_samples[1]),
        MatrixConnectivity.static_expected_connections,
        verbose=False,
        **args_dict,
    )
    result_mpf = {
        &#34;expected&#34;: cp.expected_connections(),
        &#34;total&#34;: cp.get_all_prob(),
    }

    result = monte_carlo(fn_to_eval, random_var_gen, num_iters, num_cpus=num_cpus)
    df = list_to_df(
        result,
        [&#34;Connections&#34;],
    )
    result = summarise_monte_carlo(
        df,
        plot=False,
    )
    ordered_dist = get_distribution(df, &#34;Connections&#34;, num_iters)

    return {
        &#34;full_results&#34;: df,
        &#34;summary_stats&#34;: result,
        &#34;dist&#34;: ordered_dist,
        &#34;mpf&#34;: result_mpf,
        &#34;difference&#34;: dist_difference(result_mpf[&#34;total&#34;], ordered_dist),
    }</code></pre>
</details>
</dd>
<dt id="neuroconnect.matrix.convert_mouse_data"><code class="name flex">
<span>def <span class="ident">convert_mouse_data</span></span>(<span>A_name, B_name, hemisphere='right')</span>
</code></dt>
<dd>
<div class="desc"><p>Convert general blue brain data into smaller data.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def convert_mouse_data(A_name, B_name, hemisphere=&#34;right&#34;):
    &#34;&#34;&#34;Convert general blue brain data into smaller data.&#34;&#34;&#34;
    here = os.path.dirname(os.path.realpath(__file__))
    if hemisphere == &#34;right&#34;:
        resource_dir = os.path.join(here, &#34;..&#34;, &#34;resources&#34;, &#34;right_hemisphere&#34;)
    elif hemisphere == &#34;left&#34;:
        resource_dir = os.path.join(here, &#34;..&#34;, &#34;resources&#34;, &#34;left_hemisphere&#34;)

    def load_name(name):
        return os.path.join(resource_dir, name)

    def save_name(name):
        return os.path.join(resource_dir, name + &#34;.npz&#34;)

    if os.path.isfile(
        os.path.join(resource_dir, &#34;{}_to_{}.npz&#34;.format(A_name, B_name))
    ):
        print(f&#34;Already converted this mouse data for {hemisphere} hemisphere&#34;)
        return
    print(&#34;Pulling out data from the mouse connectome&#34;)

    end_bit_indices = &#34;_ALL_INPUTS_ipsi.indices.npy&#34;
    end_bit_out = &#34;_ALL_INPUTS_ipsi.csc.npz&#34;
    end_bit_local = &#34;_ALL_INPUTS_local.csc.npz&#34;

    # Load the relevant data
    A_indices = np.load(load_name(A_name + end_bit_indices))
    B_indices = np.load(load_name(B_name + end_bit_indices))

    A_local = sparse.load_npz(load_name(A_name + end_bit_local))
    # In case some stray indices are left around
    A_small = A_local[A_indices]
    sparse.save_npz(save_name(A_name + &#34;_local&#34;), A_small)

    B_local = sparse.load_npz(load_name(B_name + end_bit_local))
    # In case some stray indices are left around
    B_small = B_local[B_indices]
    sparse.save_npz(save_name(B_name + &#34;_local&#34;), B_small)

    A = sparse.load_npz(load_name(A_name + end_bit_out))
    B_to_A = A[B_indices]
    sparse.save_npz(save_name(B_name + &#34;_to_&#34; + A_name), B_to_A)

    B = sparse.load_npz(load_name(B_name + end_bit_out))
    A_to_B = B[A_indices]
    sparse.save_npz(save_name(A_name + &#34;_to_&#34; + B_name), A_to_B)

    return</code></pre>
</details>
</dd>
<dt id="neuroconnect.matrix.gen_random_matrix"><code class="name flex">
<span>def <span class="ident">gen_random_matrix</span></span>(<span>a_size, b_size, AB_d, BA_d, AA_d, BB_d)</span>
</code></dt>
<dd>
<div class="desc"><p>Generate a full connectivity matrix at random.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def gen_random_matrix(a_size, b_size, AB_d, BA_d, AA_d, BB_d):
    &#34;&#34;&#34;Generate a full connectivity matrix at random.&#34;&#34;&#34;

    def random_gen(n_samples):
        return np.ones(shape=(n_samples,))

    AB = sparse.random(a_size, b_size, AB_d, data_rvs=random_gen, format=&#34;csr&#34;)
    BA = sparse.random(b_size, a_size, BA_d, data_rvs=random_gen, format=&#34;csr&#34;)
    AA = sparse.random(a_size, a_size, AA_d, data_rvs=random_gen, format=&#34;csr&#34;)
    BB = sparse.random(b_size, b_size, BB_d, data_rvs=random_gen, format=&#34;csr&#34;)

    return AB, BA, AA, BB</code></pre>
</details>
</dd>
<dt id="neuroconnect.matrix.graph_connectome"><code class="name flex">
<span>def <span class="ident">graph_connectome</span></span>(<span>num_sampled, max_depth, num_iters=10, graph=None, reverse_graph=None, to_write=None, num_cpus=1, a_indices=None, b_indices=None)</span>
</code></dt>
<dd>
<div class="desc"><p>Perform monte carlo graph simulations on the mouse connectome.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def graph_connectome(
    num_sampled,
    max_depth,
    num_iters=10,
    graph=None,
    reverse_graph=None,
    to_write=None,
    num_cpus=1,
    a_indices=None,
    b_indices=None,
):
    &#34;&#34;&#34;Perform monte carlo graph simulations on the mouse connectome.&#34;&#34;&#34;
    num_a, num_b = to_write

    if a_indices is None:
        a_indices = np.array([i for i in range(num_a)])
    if b_indices is None:
        b_indices = np.array([i for i in range(num_b)])

    def random_var_gen(iter_val):
        start = np.random.choice(a_indices, size=num_sampled[0], replace=False)
        end = np.random.choice(b_indices, size=num_sampled[1], replace=False)
        end = end + num_a

        return start, end

    def fn_to_eval(start, end):
        return (
            len(find_connected_limited(graph, start, end, max_depth, reverse_graph)),
        )

    result = monte_carlo(fn_to_eval, random_var_gen, num_iters, num_cpus=num_cpus)
    df = list_to_df(
        result,
        [&#34;Connections&#34;],
    )
    result = summarise_monte_carlo(
        df,
        plot=False,
    )
    ordered_dist = get_distribution(df, &#34;Connections&#34;, num_iters)

    return {
        &#34;full_results&#34;: df,
        &#34;summary_stats&#34;: result,
        &#34;dist&#34;: ordered_dist,
    }</code></pre>
</details>
</dd>
<dt id="neuroconnect.matrix.handle_pickle"><code class="name flex">
<span>def <span class="ident">handle_pickle</span></span>(<span>data, name, mode)</span>
</code></dt>
<dd>
<div class="desc"><p>Save or load data to a pickle file.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def handle_pickle(data, name, mode):
    &#34;&#34;&#34;Save or load data to a pickle file.&#34;&#34;&#34;
    pickle_name = os.path.join(os.path.dirname(pickle_loc), name)
    if mode == &#34;w&#34;:
        with open(pickle_name, &#34;wb&#34;) as handle:
            pickle.dump(data, handle, protocol=pickle.HIGHEST_PROTOCOL)
        return None

    if mode == &#34;r&#34;:
        with open(pickle_name, &#34;rb&#34;) as handle:
            b = pickle.load(handle)
        return b</code></pre>
</details>
</dd>
<dt id="neuroconnect.matrix.load_matrix_data"><code class="name flex">
<span>def <span class="ident">load_matrix_data</span></span>(<span>to_use, A_name, B_name, hemisphere='right')</span>
</code></dt>
<dd>
<div class="desc"><p>Load matrix data into a connectivity object.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>to_use</code></strong> :&ensp;<code>list</code> of <code>bool</code></dt>
<dd>Which matrices to consider, in the order [ab, ba, aa, bb]</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def load_matrix_data(to_use, A_name, B_name, hemisphere=&#34;right&#34;):
    &#34;&#34;&#34;
    Load matrix data into a connectivity object.

    Parameters
    ----------
    to_use : list of bool
        Which matrices to consider, in the order [ab, ba, aa, bb]

    &#34;&#34;&#34;
    here = os.path.dirname(os.path.realpath(__file__))
    if hemisphere == &#34;right&#34;:
        resource_dir = os.path.join(here, &#34;..&#34;, &#34;resources&#34;, &#34;right_hemisphere&#34;)
    elif hemisphere == &#34;left&#34;:
        resource_dir = os.path.join(here, &#34;..&#34;, &#34;resources&#34;, &#34;left_hemisphere&#34;)

    mc = MatrixConnectivity(
        ab=os.path.join(resource_dir, &#34;{}_to_{}.npz&#34;.format(A_name, B_name)),
        ba=os.path.join(resource_dir, &#34;{}_to_{}.npz&#34;.format(B_name, A_name)),
        aa=os.path.join(resource_dir, &#34;{}_local.npz&#34;.format(A_name)),
        bb=os.path.join(resource_dir, &#34;{}_local.npz&#34;.format(B_name)),
        to_use=to_use,
    )
    args_dict = mc.compute_stats()

    return mc, args_dict</code></pre>
</details>
</dd>
<dt id="neuroconnect.matrix.main"><code class="name flex">
<span>def <span class="ident">main</span></span>(<span>num_sampled=[3, 3], max_depth=2, num_iters=1000, do_graph=False, subsample=False, plot=False, random=False, vis_connect=False, subsample_vis=False, final=False, analyse=False, only_exp=False, A_name='VISp', B_name='VISl', desired_depth=1, desired_samples=79)</span>
</code></dt>
<dd>
<div class="desc"><p>Load data and perform calculations.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def main(
    num_sampled=[3, 3],
    max_depth=2,
    num_iters=1000,
    do_graph=False,
    # These are for checking stats on smaller data
    subsample=False,
    plot=False,
    # Generates a random matrix for comparison
    random=False,
    # Visualise the connection matrix
    vis_connect=False,
    subsample_vis=False,
    # Generate final graphs
    final=False,
    # Analyse
    analyse=False,
    only_exp=False,
    # Which regions are considered here
    # A_name, B_name = &#34;MOp&#34;, &#34;SSP-ll&#34;
    A_name=&#34;VISp&#34;,
    B_name=&#34;VISl&#34;,
    desired_depth=1,
    desired_samples=79,
):
    &#34;&#34;&#34;Load data and perform calculations.&#34;&#34;&#34;
    np.random.seed(42)

    if random:
        AB, BA, AA, BB = gen_random_matrix(150, 50, 0, 0.04, 0, 0.0)
        matrix_vis(AB, BA, AA, BB, 10, name=&#34;test_vis.png&#34;)

    os.makedirs(os.path.dirname(pickle_loc), exist_ok=True)
    convert_mouse_data(A_name, B_name)
    to_use = [True, True, True, True]
    mc, args_dict = load_matrix_data(to_use, A_name, B_name)
    print(&#34;{} - {}, {} - {}&#34;.format(A_name, B_name, mc.num_a, mc.num_b))

    result = {}
    result[&#34;matrix_stats&#34;] = print_args_dict(args_dict, out=False)

    if only_exp:
        mpf_res = mpf_connectome(mc, num_sampled, max_depth, args_dict)
        mpf_val = [
            mpf_res[&#34;expected&#34;],
            mpf_res[&#34;expected&#34;] / num_sampled[1],
            &#34;{}_{}&#34;.format(A_name, B_name),
            &#34;Statistical estimation&#34;,
        ]
        if do_graph:
            print(&#34;Converting matrix&#34;)
            gc.collect()
            mc.create_connections()
            print(&#34;Finished conversion&#34;)
            graph = mc.graph
            to_write = [mc.num_a, mc.num_b]
            del mc
            gc.collect()
            reverse_graph = reverse(graph)
            graph_res = graph_connectome(
                num_sampled,
                max_depth,
                graph=graph,
                reverse_graph=reverse_graph,
                to_write=to_write,
                num_iters=num_iters,
            )
            to_add = np.mean(graph_res[&#34;full_results&#34;][&#34;Connections&#34;].values)
            graph_val = [
                to_add,
                to_add / num_sampled[1],
                &#34;{}_{}&#34;.format(A_name, B_name),
                &#34;Statistical estimation&#34;,
            ]
            return mpf_val, graph_val
        return mpf_val, None

    # Convert to a pickle
    # if not os.path.isfile(pickle_loc):
    #     print(&#34;Converting matrix&#34;)
    #     gc.collect()
    #     mc.create_connections()
    #     print(&#34;Finished conversion&#34;)
    #     graph = mc.graph
    #     to_write = [mc.num_a, mc.num_b]
    #     del mc
    #     gc.collect()

    #     handle_pickle(graph, &#34;graph.pickle&#34;, &#34;w&#34;)
    #     handle_pickle(reverse(graph), &#34;r_graph.pickle&#34;, &#34;w&#34;)
    #     handle_pickle(to_write, &#34;graph_size.pickle&#34;, &#34;w&#34;)

    if vis_connect:
        if subsample_vis:
            print(&#34;Plotting subsampled matrix vis&#34;)
            new_mc = mc.subsample(int(mc.num_a / 10), int(mc.num_b / 10))
            matrix_vis(
                new_mc.ab,
                new_mc.ba,
                new_mc.aa,
                new_mc.bb,
                15,
                name=&#34;mc_mat_vis_sub10.pdf&#34;,
            )
        else:
            o_name = &#34;mc_mat_vis_{}_to_{}.pdf&#34;.format(A_name, B_name)
            print(&#34;Plotting full matrix vis&#34;)
            matrix_vis(mc.ab, mc.ba, mc.aa, mc.bb, 150, name=o_name)
        print(&#34;done vis&#34;)

    print(mc, print_args_dict(args_dict, out=False))

    result = None
    if subsample:
        result = check_stats(mc, 1000, 1, 20000, 1, plot)
    if final:
        result = {}

        # For different depths and number of samples
        for depth in range(1, 4):
            for ns in range(1, num_sampled[0] + 1):
                ns_2 = [ns] * 2
                mpf_res = mpf_connectome(mc, ns_2, depth, args_dict)
                result[&#34;mpf_{}_{}&#34;.format(depth, ns)] = mpf_res

        # Save this for plotting
        cols = [&#34;Number of samples&#34;, &#34;Proportion of connections&#34;, &#34;Max distance&#34;]
        depth_name = [None, &#34;Direct synapse&#34;, &#34;Two synapses&#34;, &#34;Three synapses&#34;]
        vals = []
        for depth in range(1, 4):
            for ns in range(1, num_sampled[0] + 1):
                this = result[&#34;mpf_{}_{}&#34;.format(depth, ns)]
                val = [ns, this[&#34;expected&#34;] / ns, depth_name[depth]]
                vals.append(val)
        df = pd.DataFrame(vals, columns=cols)
        os.makedirs(os.path.join(here, &#34;..&#34;, &#34;results&#34;), exist_ok=True)
        df.to_csv(
            os.path.join(
                here, &#34;..&#34;, &#34;results&#34;, &#34;{}_to_{}_depth.csv&#34;.format(A_name, B_name)
            ),
            index=False,
        )

        cols = [&#34;Number of sampled connected neurons&#34;, &#34;Probability&#34;]
        total_pmf = result[&#34;mpf_{}_{}&#34;.format(desired_depth, desired_samples)][&#34;total&#34;]
        vals = []
        for k, v in total_pmf.items():
            vals.append([k, float(v)])
        df = pd.DataFrame(vals, columns=cols)
        df.to_csv(
            os.path.join(
                here,
                &#34;..&#34;,
                &#34;results&#34;,
                &#34;{}_to_{}_pmf_{}_{}.csv&#34;.format(
                    A_name, B_name, desired_depth, desired_samples
                ),
            ),
            index=False,
        )
    if analyse:
        result = {}
        result[&#34;matrix_stats&#34;] = args_dict

        mpf_res = mpf_connectome(
            mc,
            num_sampled,
            max_depth,
            args_dict,
            clt_start=30,
            sr=None,
            mean_estimate=True,
        )
        result[&#34;mean&#34;] = mpf_res

        vals = []
        cols = [&#34;Number of connected neurons&#34;, &#34;Probability&#34;, &#34;Calculation&#34;]
        for k, v in mpf_res[&#34;total&#34;].items():
            vals.append([k, float(v), &#34;Mean estimation&#34;])

        mpf_res = mpf_connectome(mc, num_sampled, max_depth, args_dict, clt_start=30)
        result[&#34;mpf&#34;] = mpf_res

        for k, v in mpf_res[&#34;total&#34;].items():
            vals.append([k, float(v), &#34;Statistical estimation&#34;])

        if do_graph:
            print(&#34;Converting matrix&#34;)
            gc.collect()
            mc.create_connections()
            print(&#34;Finished conversion&#34;)
            graph = mc.graph
            to_write = [mc.num_a, mc.num_b]
            del mc
            gc.collect()
            reverse_graph = reverse(graph)

            graph_res = graph_connectome(
                num_sampled,
                max_depth,
                graph=graph,
                reverse_graph=reverse_graph,
                to_write=to_write,
                num_iters=num_iters,
            )

            result[&#34;difference&#34;] = (
                dist_difference(mpf_res[&#34;total&#34;], graph_res[&#34;dist&#34;]),
            )
            result[&#34;graph&#34;] = graph_res

            for k, v in graph_res[&#34;dist&#34;].items():
                vals.append([k, float(v), &#34;Monte Carlo simulation&#34;])

        df = pd.DataFrame(vals, columns=cols)
        df.to_csv(
            os.path.join(
                here,
                &#34;..&#34;,
                &#34;results&#34;,
                &#34;{}_to_{}_pmf_final_{}_{}.csv&#34;.format(
                    A_name, B_name, max_depth, num_sampled[0]
                ),
            ),
            index=False,
        )

    if result is not None:
        with open(os.path.join(here, &#34;..&#34;, &#34;results&#34;, &#34;mouse.txt&#34;), &#34;w&#34;) as f:
            pprint(result, width=120, stream=f)

    return result</code></pre>
</details>
</dd>
<dt id="neuroconnect.matrix.make_full_matrix"><code class="name flex">
<span>def <span class="ident">make_full_matrix</span></span>(<span>AB, BA, AA, BB)</span>
</code></dt>
<dd>
<div class="desc"><p>Combine separate into one sparse matrix.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def make_full_matrix(AB, BA, AA, BB):
    &#34;&#34;&#34;Combine separate into one sparse matrix.&#34;&#34;&#34;
    a_size, b_size = AB.shape

    full_mat = sparse.csc_matrix((a_size + b_size, a_size + b_size))
    full_mat[:a_size, :a_size] = AA
    full_mat[:a_size, a_size:] = AB
    full_mat[a_size:, :a_size] = BA
    full_mat[a_size:, a_size:] = BB

    return full_mat</code></pre>
</details>
</dd>
<dt id="neuroconnect.matrix.mpf_connectome"><code class="name flex">
<span>def <span class="ident">mpf_connectome</span></span>(<span>mc, num_sampled, max_depth, args_dict, clt_start=10, sr=0.01, mean_estimate=False)</span>
</code></dt>
<dd>
<div class="desc"><p>Perform mpf statistical calculations on the mouse connectome.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def mpf_connectome(
    mc, num_sampled, max_depth, args_dict, clt_start=10, sr=0.01, mean_estimate=False
):
    &#34;&#34;&#34;Perform mpf statistical calculations on the mouse connectome.&#34;&#34;&#34;
    args_dict[&#34;max_depth&#34;] = max_depth
    args_dict[&#34;total_samples&#34;] = num_sampled[0]
    args_dict[&#34;static_verbose&#34;] = False
    args_dict[&#34;clt_start&#34;] = clt_start
    args_dict[&#34;mean_estimate&#34;] = mean_estimate

    if max_depth &gt; 1:
        sr = None
    if mean_estimate is True:
        sr = None

    cp = CombProb(
        mc.num_a,
        num_sampled[0],
        mc.num_senders,
        mc.num_b,
        num_sampled[1],
        MatrixConnectivity.static_expected_connections,
        verbose=True,
        subsample_rate=sr,
        **args_dict,
    )
    result = {
        &#34;expected&#34;: cp.expected_connections(),
        &#34;total&#34;: cp.get_all_prob(),
        &#34;each_expected&#34;: {k: cp.expected_total(k) for k in range(num_sampled[0] + 1)},
    }

    return result</code></pre>
</details>
</dd>
<dt id="neuroconnect.matrix.mpf_probe_connectome"><code class="name flex">
<span>def <span class="ident">mpf_probe_connectome</span></span>(<span>mc, num_sampled, a_indices, b_indices, max_depth, args_dict, clt_start=10, sr=0.01, mean_estimate=False, force_no_mean=False)</span>
</code></dt>
<dd>
<div class="desc"><p>Perform mpf statistical calculations on the mouse connectome with a probe.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def mpf_probe_connectome(
    mc,
    num_sampled,
    a_indices,
    b_indices,
    max_depth,
    args_dict,
    clt_start=10,
    sr=0.01,
    mean_estimate=False,
    force_no_mean=False,
):
    &#34;&#34;&#34;Perform mpf statistical calculations on the mouse connectome with a probe.&#34;&#34;&#34;
    probe_stats = mc.compute_probe_stats(
        a_indices,
        b_indices,
    )
    sub_mc = probe_stats[&#34;probes&#34;]
    sub_args_dict = probe_stats[&#34;stats&#34;]
    for k, v in sub_args_dict.items():
        args_dict[f&#34;{k}_probe&#34;] = v
    sub_args_dict = probe_stats[&#34;A_stats&#34;]
    for k, v in sub_args_dict.items():
        args_dict[f&#34;{k}_A&#34;] = v
    sub_args_dict = probe_stats[&#34;B_stats&#34;]
    for k, v in sub_args_dict.items():
        args_dict[f&#34;{k}_B&#34;] = v
    sub_args_dict = probe_stats[&#34;inter&#34;]
    for k, v in sub_args_dict.items():
        args_dict[k] = v

    args_dict[&#34;max_depth&#34;] = max_depth
    args_dict[&#34;total_samples&#34;] = num_sampled[0]
    args_dict[&#34;static_verbose&#34;] = False
    args_dict[&#34;clt_start&#34;] = clt_start
    args_dict[&#34;mean_estimate&#34;] = mean_estimate

    if force_no_mean:
        args_dict[&#34;use_mean&#34;] = False

    if max_depth &gt; 1:
        sr = None
    if mean_estimate is True:
        sr = None

    # This comb prob is for depth =-1
    # If you call senders dist it only works for dpeth = 1
    # Inside of the detla function static_expected_connections
    # Ti instead works correctly for dpth != 1
    cp = CombProb(
        sub_mc.num_a,
        num_sampled[0],
        sub_mc.num_senders,
        sub_mc.num_b,
        num_sampled[1],
        MatrixConnectivity.static_expected_connections,
        verbose=True,
        subsample_rate=sr,
        **args_dict,
    )
    result = {
        &#34;expected&#34;: cp.expected_connections(),
        &#34;total&#34;: cp.get_all_prob(),
        &#34;each_expected&#34;: {k: cp.expected_total(k) for k in range(num_sampled[0] + 1)},
    }

    return result</code></pre>
</details>
</dd>
<dt id="neuroconnect.matrix.print_args_dict"><code class="name flex">
<span>def <span class="ident">print_args_dict</span></span>(<span>args_dict, out=True)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def print_args_dict(args_dict, out=True):
    to_print = {}
    for v in (&#34;N&#34;, &#34;num_start&#34;, &#34;num_senders&#34;, &#34;num_recurrent&#34;):
        to_print[v] = args_dict[v]
    for v in (
        &#34;out_connections_dist&#34;,
        &#34;recurrent_connections_dist&#34;,
        &#34;start_inter_dist&#34;,
        &#34;end_inter_dist&#34;,
    ):
        to_print[v] = (get_dist_mean(args_dict[v]), get_dist_var(args_dict[v]))

    if out:
        print(to_print)

    return to_print</code></pre>
</details>
</dd>
</dl>
</section>
<section>
</section>
</article>
<nav id="sidebar">
<h1>Index</h1>
<div class="toc">
<ul></ul>
</div>
<ul id="index">
<li><h3>Super-module</h3>
<ul>
<li><code><a title="neuroconnect" href="index.html">neuroconnect</a></code></li>
</ul>
</li>
<li><h3><a href="#header-functions">Functions</a></h3>
<ul class="">
<li><code><a title="neuroconnect.matrix.check_stats" href="#neuroconnect.matrix.check_stats">check_stats</a></code></li>
<li><code><a title="neuroconnect.matrix.convert_mouse_data" href="#neuroconnect.matrix.convert_mouse_data">convert_mouse_data</a></code></li>
<li><code><a title="neuroconnect.matrix.gen_random_matrix" href="#neuroconnect.matrix.gen_random_matrix">gen_random_matrix</a></code></li>
<li><code><a title="neuroconnect.matrix.graph_connectome" href="#neuroconnect.matrix.graph_connectome">graph_connectome</a></code></li>
<li><code><a title="neuroconnect.matrix.handle_pickle" href="#neuroconnect.matrix.handle_pickle">handle_pickle</a></code></li>
<li><code><a title="neuroconnect.matrix.load_matrix_data" href="#neuroconnect.matrix.load_matrix_data">load_matrix_data</a></code></li>
<li><code><a title="neuroconnect.matrix.main" href="#neuroconnect.matrix.main">main</a></code></li>
<li><code><a title="neuroconnect.matrix.make_full_matrix" href="#neuroconnect.matrix.make_full_matrix">make_full_matrix</a></code></li>
<li><code><a title="neuroconnect.matrix.mpf_connectome" href="#neuroconnect.matrix.mpf_connectome">mpf_connectome</a></code></li>
<li><code><a title="neuroconnect.matrix.mpf_probe_connectome" href="#neuroconnect.matrix.mpf_probe_connectome">mpf_probe_connectome</a></code></li>
<li><code><a title="neuroconnect.matrix.print_args_dict" href="#neuroconnect.matrix.print_args_dict">print_args_dict</a></code></li>
</ul>
</li>
</ul>
</nav>
</main>
<footer id="footer">
<p>Generated by <a href="https://pdoc3.github.io/pdoc" title="pdoc: Python API documentation generator"><cite>pdoc</cite> 0.10.0</a>.</p>
</footer>
</body>
</html>